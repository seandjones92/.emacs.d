#+TITLE: Emacs configuration file
#+AUTHOR: Sean Jones
#+OPTIONS: toc:2
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About

This configuration is based off of the system shown [[https://github.com/larstvei/dot-emacs][here]]. The idea is
that the configuration should serve as it's own plain english
documentation.

Install with:
#+BEGIN_SRC sh :tangle no
  git clone git@github.com:seandjones92/Emacs.git ~/.emacs.d
#+END_SRC

Once the repo is cloned execute the following commands to prevent the
dynamic configuration from being tracked in git:
#+BEGIN_SRC sh :tangle no
  cd ~/.emacs.d
  git update-index --assume-unchanged init.el
#+END_SRC

If you want to make changes to the repo-version of init.el start tracking again with:
#+BEGIN_SRC sh :tangle no
  git update-index --no-assume-unchanged init.el
#+END_SRC

* Configurations (Internal)
This section contains all of the configurations that do not rely on
external packages. If the configuration cannot be accomplished by a
standalone Emacs installation with no internet connection then it does
not belong here.

** Meta

All changes to the config should be made to =init.org=, *not* to
=init.el=. The running configuration is generated at first launch and
whenever =init.org= is saved from within Emacs. Any changes made
directly to =init.el= will be lost, it is regenerated regularly.

The initial =init.el= looks like this:
#+BEGIN_SRC emacs-lisp :tangle no
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, replacing itself with the actual configuration.

To make sure that the encoding prompt is not shown on launch we start
the init with this line:
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
#+END_SRC

The function defined below generates a new =init.el= each time
=init.org= is saved from within Emacs.

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled, and the tangled file is compiled"
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

This section will generate =README.md= after each save.
#+BEGIN_SRC emacs-lisp
  (defun generate-init-readme ()
    "If the current buffer is 'init.org' then 'README.md' is generated"
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks
      (let ((prog-mode-hook nil))
        (org-md-export-to-markdown)
        (rename-file "init.md" "README.md" t))))

  (add-hook 'after-save-hook 'generate-init-readme)
#+END_SRC

If there is anything that should be kept private (not tracked by git,
and therefore not in this configuration) put it in
=~/.emacs.d/private.el=, it will be loaded if it exists.
#+BEGIN_SRC emacs-lisp
  (add-hook
   'after-init-hook
   (lambda ()
     (let ((private-file (concat user-emacs-directory "private.el")))
       (when (file-exists-p private-file)
         (load-file private-file)))))
#+END_SRC

** Windows
This section is for defining any behavior needed for the configuration
to work properly on Windows. Unfortunately I have to use Windows at
work so these configurations are a must for me.

#+BEGIN_SRC emacs-lisp
  (defun my-windows-config ()
    (setq default-directory (concat "C:\\Users\\" (user-login-name) "\\"))
    (setq python-shell-interpreter "py.exe"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'windows-nt)
      (my-windows-config))
#+END_SRC

** Base defaults
Here we define the basic look and feel of Emacs.

Remove scrollbars, menu bars, and toolbars:
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC

Instead of typeing "yes" or "no" for interactive functions followed by
=<enter>=, all you need to do is press "y" or "n". No =<enter>=
required!
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Disable the system bell. No flashing, no sounds.
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

Enable column numbers.
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC

For me this allows for better handling of parenthesis and quotes. As
you type =(= a matching =)= is also created. The same goes for
quotes. It also adds some inteligent handling. Further in the
configuration we use =paredit=, which takes things a step further.
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
  (require 'paren)
  (setq show-paren-style 'parenthesis)
  (show-paren-mode 1)
#+END_SRC

Enable spell checking.
#+BEGIN_SRC emacs-lisp
  (setq ispell-dictionary "american")
#+END_SRC

Disable word wrapping by default, I don't like it.
#+BEGIN_SRC emacs-lisp
  (set-default 'truncate-lines t)
#+END_SRC

Use =*scratch*= as initial screen. Also, modify the message at the top
of the buffer.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
  (setq initial-scratch-message ";; Scratch page\n\n")
#+END_SRC

** Functions
These are my custom functions. I define them all here. If I want them
assigned to a keybinding I do so later in the config.

This function is to be run in =dired=. It prompts for a regular
expression and only shows the entries (files or directories) that
match that regular expression. This is good for working in directories
with lots of files. Think =ls -al | grep -E <expression>=.
#+BEGIN_SRC emacs-lisp
  (defun dired-show-only (regexp)
    "Only show files matching the regexp."
    (interactive "sFiles to show (regexp): ")
    (dired-mark-files-regexp regexp)
    (dired-toggle-marks)
    (dired-do-kill-lines))
#+END_SRC

This function is used to terminate all TRAMP connections and to kill
all buffers associated with TRAMP connections. Sometimes I'll have a
lot going on, machines I'm no longer working on, too many buffers to
sort through and this helps.
#+BEGIN_SRC emacs-lisp
  (defun go-local ()
    "Clean up all remote connections."
    (interactive)
    (ignore-errors (tramp-cleanup-all-connections))
    (ignore-errors (tramp-cleanup-all-buffers)))
#+END_SRC

This, in my opinion, is how Emacs should behave by default when saving
files. Strip all white space from the end of the file and the ends of
lines before saving.
#+BEGIN_SRC emacs-lisp
  (defun save-buffer-clean ()
    "Strip the trailing whitespace from a file and save it."
    (interactive)
    (delete-trailing-whitespace)
    (save-buffer))
#+END_SRC

Again, another function to get what I would like to be default
behavior. This one handles killing buffers. If there is more than one
buffer and I kill one, kill its window too.
#+BEGIN_SRC emacs-lisp
  (defun smart-buffer-kill ()
    "Kill buffers in a way that makes sense."
    (interactive)
    (if (= (count-windows) 1)
        (kill-buffer)
      (kill-buffer-and-window)))
#+END_SRC

This is one I don't use very often but can be useful. Copy the SSH
public key to the clipboard.
#+BEGIN_SRC emacs-lisp
  (defun ssh-clip ()
    "Copy '~/.ssh/id_rsa.pub' to clipboard.
  This will first empty the kill-ring (clipboard)"
    (interactive)
    (if (= (count-windows) 1)
        (let ((origin (current-buffer)))
          (setq kill-ring nil)
          (find-file "~/.ssh/id_rsa.pub")
          (mark-page)
          (kill-ring-save (point-min) (point-max))
          (kill-buffer)
          (message "Public key copied to clipboard"))
      (let ((origin (current-buffer)))
        (setq kill-ring nil)
        (find-file-other-window "~/.ssh/id_rsa.pub")
        (mark-page)
        (kill-ring-save (point-min) (point-max))
        (kill-buffer)
        (switch-to-buffer-other-window origin)
        (message "Public key copied to clipboard"))))
#+END_SRC

** Org Mode

Here is my functional configuration of Org Mode.

Right now, all I really need to change from the default is to enable
more babel languages.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((java . t)
     (js . t)
     (sql . t)
     (clojure . t)
     (lisp . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (scheme . t)
     (sh . t)))
#+END_SRC

** Mode hooks
This is where mode hooks are manipulated.
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'text-mode-hook 'toggle-truncate-lines)
  (add-hook 'org-mode-hook 'turn-on-font-lock)
  (add-hook 'sh-mode-hook 'linum-mode)
  (add-hook 'python-mode-hook 'linum-mode)
#+END_SRC

** Keybindings

This is where I define my custom keybindings.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-k") 'smart-buffer-kill)
  (global-set-key (kbd "C-x C-s") 'save-buffer-clean)
  (require 'dired)
  (define-key dired-mode-map [?%?h] 'dired-show-only)
#+END_SRC

Enable keybindings that are disabled by default:
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-page 'disabled nil)
#+END_SRC

* Configurations (External)
Configurations after this point rely on external packages. Anything
added from here on out should be designed to fail gracefully in case
the package is not available.

** Packages
This section goes over the configuration of package management. To
start this off we need to define a few things. First we will configure
the repositories we wish to use. The =jorgenschaefer.github.io= repo
is only needed for the Elpy package.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("elpy" . "https://jorgenschaefer.github.io/packages/")))
#+END_SRC

Next we define a function to determine if we have access to the
internet. We need to wrap this in a check for Windows since =ping=
options behave differently.
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'windows-nt)
      (defun internet-up ()
          (call-process "ping" nil nil nil "-n" "1" "www.google.com"))
    (defun internet-up ()
        (call-process "ping" nil nil nil "-c" "1" "www.google.com")))
#+END_SRC

Next we define a list containing all of the packages that should be
installed to take full advantage of this configuration. The Silver
Searcher should be installed to use the =ag= and =helm-ag= packages.
#+BEGIN_SRC emacs-lisp
  (setq my-packages '(ag
                      all-the-icons
                      auto-complete
                      cider
                      elpy
                      gist
                      helm
                      helm-ag
                      helm-projectile
                      hlinum
                      magit
                      markdown-mode
                      moe-theme
                      multiple-cursors
                      neotree
                      org-bullets
                      paredit
                      projectile
                      powerline
                      zeal-at-point))
#+END_SRC

The next function defined is to loop through the provided list of
packages and to check if they are present. If not, the package is
installed:
#+BEGIN_SRC emacs-lisp
  (defun auto-package-mgmt ()
    "Install my packages"
    (package-initialize)
    (package-refresh-contents)
    (dolist (package my-packages)
      (if (ignore-errors (require package))
          (message "%s is already installed..." package)
        (package-install package))))
#+END_SRC

*TODO:* This should only be automatic the first time emacs is loaded,
it should be interactive from there on out.

To tie it all together we bring in the logic. If we have access to the
internet loop through the list of packages to ensure they are
installed. If we do not have access to the internet nothing is
done. Package dependent configuration is handled gracefully so if
there is no internet there should be no issue.
#+BEGIN_SRC emacs-lisp
  (if (internet-up)
      (auto-package-mgmt))
#+END_SRC

** Auto Complete
Here is where auto complete is configured. The =ac-sources= variable
needs to be set or the completion framework won't kick in.
#+BEGIN_SRC emacs-lisp
  (defun my-autocomplete-setup ()
    (ac-config-default)
    (setq-default ac-sources '(ac-source-filename
                               ac-source-functions
                               ac-source-yasnippet
                               ac-source-variables
                               ac-source-symbols
                               ac-source-features
                               ac-source-abbrev
                               ac-source-words-in-same-mode-buffers
                               ac-source-dictionary)))

  (if (require 'auto-complete-config)
      (my-autocomplete-setup))
#+END_SRC

** Elpy
Elpy is used to get IDE like functionality for Python. To get full use
of this package run =pip install jedi flake8 importmagic autopep8=.

#+BEGIN_SRC emacs-lisp
  (defun my-elpy-keybindings ()
    (define-key elpy-mode-map (kbd "<f12>") 'elpy-goto-definition-other-window))

  (defun my-elpy-setup ()
    (package-initialize)
    (elpy-enable)
    (add-hook 'elpy-mode-hook 'my-elpy-keybindings))

  (if (require 'elpy)
      (my-elpy-setup))
#+END_SRC

** Helm
[[https://github.com/emacs-helm/helm][Helm]] is an Emacs framework for incremental completions and narrowing
selections. It's a much better way to interact with Emacs. I've broken
it out into smaller chunks so I can better explain what's going on.

This section enables fuzzy finding in almost everything Helm
does. This helps to really speed up interaction with emacs since you
can just type a couple partially completed words to get full phrases
instead of spelling everything out.
#+BEGIN_SRC emacs-lisp
  (defun my-helm-fuzzy-settings ()
    (setq helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-apropos-fuzzy-match t
          helm-lisp-fuzzy-completion t
          helm-mode-fuzzy-match t
          helm-completion-in-region-fuzzy-match t))
#+END_SRC

This part is where keybindings relevant to Helm are defined. The one
I've found to be most useful is =helm-mini= which is activated with
=C-x x=. This will show you currently open buffers and recent files.
#+BEGIN_SRC emacs-lisp
  (defun my-helm-keybindings ()
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))
    (global-set-key (kbd "M-x") 'helm-M-x)
    (global-set-key (kbd "M-y") 'helm-show-kill-ring)
    (global-set-key (kbd "C-x x") 'helm-mini)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)
    (global-set-key (kbd "C-c h o") 'helm-occur)
    (global-set-key (kbd "C-x C-b") 'helm-buffers-list)
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action))
#+END_SRC

This section has some more miscellaneous settings. In all honesty I
need to research them a bit more to accuratly describe what each of
these does.
#+BEGIN_SRC emacs-lisp
  (defun my-helm-misc ()
    (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

    (when (executable-find "curl")
      (setq helm-net-prefer-curl t))

    (when (executable-find "ack-grep")
      (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
            helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))

    (setq helm-split-window-inside-p t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-ff-file-name-history-recentf t))
#+END_SRC

This section tells the Helm interface that it should resize itself
depending on how much content it has to display, but should take up no
more than 65 percent of the Emacs interface.
#+BEGIN_SRC emacs-lisp
  (defun my-helm-sizing ()
    (helm-autoresize-mode 1)
    (setq helm-autoresize-max-height 65))
#+END_SRC

Next we tie all of these pieces together in a setup function. It is
important to have the =(require 'helm-config)= on top or else the
configuration will fail.
#+BEGIN_SRC emacs-lisp
  (defun my-helm-setup ()
    (require 'helm-config)
    (my-helm-fuzzy-settings)
    (my-helm-keybindings)
    (my-helm-misc)
    (my-helm-sizing)
    (helm-mode 1))
#+END_SRC

Finally we will check to see if Helm is available before applying any
of these settings.
#+BEGIN_SRC emacs-lisp
  (if (require 'helm)
      (my-helm-setup))
#+END_SRC

** Magit
Magit is something that, in my opinion, should be shipped by default
with Emacs. It's the most robust Git interface out there.
#+BEGIN_SRC emacs-lisp
  (defun my-magit-setup ()
    (global-set-key (kbd "C-x g") 'magit-status)
    (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup))

  (if (require 'magit)
      (my-magit-setup))
#+END_SRC

** Multiple cursors

#+BEGIN_SRC emacs-lisp
  (defun my-multicursor-setup ()
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))

  (if (require 'multiple-cursors)
      (my-multicursor-setup))
#+END_SRC

** Paredit
This is for better handling of S-expressions in lisp languages
#+BEGIN_SRC emacs-lisp
  (autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  (add-hook 'eshell-mode-hook           #'enable-paredit-mode)
  (add-hook 'clojure-mode-hook          #'enable-paredit-mode)
  (add-hook 'cider-repl-mode            #'enable-paredit-mode)
#+END_SRC

** Projectile

#+BEGIN_SRC emacs-lisp
  (defun my-projectile-keybindings ()
    (define-key projectile-mode-map (kbd "C-c a") 'helm-projectile-ag))

  (defun my-projectile-setup ()
    (projectile-mode)
    (projectile-discover-projects-in-directory default-directory)
    (add-hook 'projectile-mode-hook 'my-projectile-keybindings))

  (if (require 'projectile)
      (my-projectile-setup))
#+END_SRC

** Highlight line number

#+BEGIN_SRC emacs-lisp
  (if (require 'hlinum)
      (hlinum-activate))
#+END_SRC

** Neotree
In order for this to look right the fonts for =all-the-icons= must be
installed. This is accomplished by =M-x all-the-icons-install-fonts=.
#+BEGIN_SRC emacs-lisp
  (defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))

  (defun my-neotree-setup ()
    (global-set-key (kbd "C-c n") 'neotree-project-dir)
    (if (eq system-type 'windows-nt)
        (setq neo-theme 'arrow)
      (setq neo-theme 'icons))
    (setq projectile-switch-project-action 'neotree-projectile-action)
    (setq neo-window-width 30))

  (if (require 'neotree)
      (my-neotree-setup))
#+END_SRC

** Themeing

#+BEGIN_SRC emacs-lisp
  (defun my-moetheme-setup ()
    (setq moe-theme-highlight-buffer-id t)
    (setq moe-theme-resize-markdown-title '(2.0 1.7 1.5 1.3 1.0 1.0))
    (setq moe-theme-resize-org-title '(2.2 1.8 1.6 1.4 1.2 1.0 1.0 1.0 1.0))
    (moe-dark))

  (defun my-moetheme-with-powerline ()
    (powerline-moe-theme)
    (setq moe-theme-highlight-buffer-id t)
    (setq moe-theme-resize-markdown-title '(2.0 1.7 1.5 1.3 1.0 1.0))
    (setq moe-theme-resize-org-title '(2.0 1.7 1.5 1.3 1.0 1.0 1.0 1.0 1.0))
    (moe-dark)
    (setq powerline-default-separator 'wave))

  (if (require 'powerline)
      (if (require 'moe-theme)
          (my-moetheme-with-powerline))
    (if (require 'moe-theme)
        (my-moetheme-setup)))

  (if (require 'org-bullets)
      (add-hook 'org-mode-hook
                (lambda ()
                  (org-bullets-mode 1))))
#+END_SRC

** Zeal

Offline documentation. Make sure [[https://zealdocs.org/][Zeal]] is installed first.
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-cd" 'zeal-at-point)
#+END_SRC

If you are on Windows you need to add Zeal to the exec path.
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'windows-nt)
      (add-to-list 'exec-path "C:/Program Files/Zeal"))
#+END_SRC

* Systemd unit file
Here is an example of a unit file for the emacs daemon. Place this in
=~/.config/systemd/user/emacs.service=.

#+BEGIN_SRC sh :tangle no
  [Unit]
  Description=Emacs: the extensible, self-documenting text editor

  [Service]
  Type=forking
  ExecStart=/usr/bin/emacs --daemon
  ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
  Environment=SSH_AUTH_DOCK=%t/keyring/ssh
  Restart=always

  [Install]
  WantedBy=default.target
#+END_SRC

Once this is created run =systemctl enable --user emacs.service= to
enable the daemon, and =systemctl start --user emacs.service=

* Licensing
Â© Copyright 2016 Sean Jones

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
